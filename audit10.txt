OU ARE RUNNING TSOT STEP 5: CLASSIFICATION (AUDIT ONLY). NO CODE EDITS.

Context:
- Repo: MPX3
- Canonical time source of truth: trading_app/time_spec.py
- Detector output file: time_literal_inventory.txt (generated by scripts/check/check_time_literals.py)
- Strategy: Grandfather existing code; WARN-only enforcement; no mass refactor.
- Constraints: Follow GUARDIAN.md. Do not modify trading logic, pipeline, or DB writes. Do not edit any code files. Only generate audit artifacts.
- Goal: Produce a migration plan that is deterministic, de-duplicated, and future-proof.

INPUT:
- Read and parse: time_literal_inventory.txt
  - IMPORTANT: file may contain ANSI color codes and may be UTF-16 or UTF-8. Your parser must handle both.
  - Each violation is grouped like:
    [X] <file_path>
      Line N: "<line text>"
        Pattern: <regex>

CLASSIFICATION RULES (STRICT):
1) STRUCTURAL (must migrate):
   - Any literal that defines ORB/session logic, lists ORB times, loops over ORB strings, dict keys/metadata used by logic, time window logic, session boundaries, schedule decisions, validation gates, scanner logic, or anything that changes behavior.
2) UI/DISPLAY (allowed to keep):
   - Literal appears only in human-facing text: labels, tooltips, markdown, help strings, examples, docs, plot titles, placeholder chat prompts.
3) AMBIGUOUS:
   - If you cannot prove it is UI-only, classify as STRUCTURAL (fail-closed).
4) DEDUPING:
   - De-duplicate repeated hits for the same (file, line, pattern).
   - Also de-duplicate multiple patterns matching the same literal on the same line.

MAPPING RULES:
- For each STRUCTURAL hit, map it to an existing export from trading_app/time_spec.py.
- If you cannot find a matching constant, emit it as MISSING_CONSTANT and list the exact literal needed (but DO NOT edit time_spec.py).
- If multiple possible constants exist, pick the best one and note alternates.

OUTPUTS (WRITE FILES, NO OTHER SIDE EFFECTS):
1) tsot_migration_map.json
   Schema:
   {
     "generated_at": "...",
     "source_inventory": "time_literal_inventory.txt",
     "totals": { "files": X, "violations": Y, "deduped_violations": Z },
     "by_file": {
        "<path>": {
          "structural": [
            {
              "line": N,
              "literal": "0900",
              "context": "<trimmed line text>",
              "pattern": "<pattern>",
              "recommended_import": "from trading_app.time_spec import ORBS",
              "replacement_plan": "Replace ['0900','1000',...] with ORBS (or ORB_TIMES) depending on context",
              "confidence": "high|medium|low",
              "notes": "..."
            }
          ],
          "ui_display": [...],
          "missing_constant": [...]
        }
     },
     "top_priority_files": [
        { "path": "...", "structural_count": n, "reason": "..." }
     ]
   }

2) TSOT_STEP5_REPORT.md (short executive summary)
   Must include:
   - counts: structural vs ui_display vs missing_constant
   - top 10 files by structural count
   - “ready for Step 6” section describing safest execution order:
     - start with lowest blast radius utility modules
     - then scanners
     - then app_canonical last
   - explicit reminder: checker exit code 1 == violations found (not a crash)

PROCESS:
- Read GUARDIAN.md first and obey it.
- Then parse inventory, classify, map to time_spec exports, produce outputs.
- Do not assume any table exists. Do not touch DuckDB. No code edits. No refactors.

Return only:
- file paths created
- high-level counts
- top priority files list