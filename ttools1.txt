Step 1 â€” Understand the pieces (plain English)

There are 4 different extension mechanisms in Claude Code. Most people confuse them.

1) Skills (you already touched this)

What: Markdown files Claude reads when invoked

Purpose: Persistent rules, preferences, memory

Stateful? Yes (via file edits)

You control: 100%

ğŸ‘‰ This is your long-term memory + behavior layer

2) Agents (sub-agents)

What: Named workers with a role + tools

Purpose: Offload tasks without polluting main context

Examples:

planner â†’ designs approach

explore â†’ scans repo fast

bash â†’ runs commands

reviewer â†’ critiques code

Stateful? No (ephemeral per run)

Invocation:

@agentname

or â€œuse the X agent toâ€¦â€

ğŸ‘‰ This is parallel brains, not memory

3) Plugins / Tools

What: External capabilities (FS, shell, git, HTTP, etc.)

Purpose: Let Claude do things, not just think

Examples:

file system access

git commit

shell scripts

hooks

Stateful? Indirectly (via files/DBs)

You donâ€™t write these â€” Claude Code exposes them

ğŸ‘‰ This is hands, not intelligence

4) Hooks (automation glue)

What: Scripts triggered by events

Purpose: Automation + lifecycle control

Examples:

on session stop

after command

before exit

ğŸ‘‰ This is autopilot

Confirm this mental model makes sense before we continue.

Step 2 â€” The actual minimal setup you need

You only need ONE of each:

Required

âœ… skills/reflect.md â†’ learning engine

âœ… 1â€“2 core skills (code_review, project_conventions)

âœ… Built-in agents (already there, you just arenâ€™t using them)

Optional (later)

â³ stop hook

â³ auto-reflect

You are not missing 50 features. Youâ€™re missing activation.

Confirm.

Step 3 â€” How to use agents (you already have them)

You donâ€™t install agents. They already exist.

Ways to invoke

Explicit:

@explore scan the repo for duplicate logic


Implicit:

use the explore agent to find where RR is calculated

Best practice (important)

Use agents for:

scanning

planning

validation

Keep main thread for decisions

This protects context and reduces hallucination.

Confirm.

Step 4 â€” How skills + agents + reflect connect (this is the â€œsystemâ€)

Flow:

You work with Claude (agents help)

You correct something

You run /reflect

Reflect updates a skill

Next session:

That skill changes how Claude behaves

Agents inherit that behavior automatically

Thatâ€™s the self-improving loop.

No DB required.

Step 5 â€” Why you feel like youâ€™re â€œnot using featuresâ€

Because Claude Code is pull-based, not push-based.

Nothing activates unless:

you invoke a skill

you call an agent

a hook fires

There is no hidden magic mode youâ€™re missing.

Step 6 â€” What I recommend for you specifically

Given:

large repo

ADHD overload

strong need for canonical control

Your ideal stack:

Skills:

project_conventions.md

code_review.md

reflect.md

Agents you actually use:

explore (repo scanning)

planner (before big changes)

bash (execution only)

Hooks:

âŒ auto-reflect (for now)

âœ… manual /reflect

This gives power without chaos.