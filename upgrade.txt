WORK DISCIPLINE (MANDATORY)

You MUST:
1) Break this work into an explicit numbered task list before writing code.
2) Each task must include:
   - Purpose
   - Inputs
   - Outputs
   - Definition of Done (verifiable)
3) Complete tasks strictly in order. Do NOT jump ahead.
4) After each task:
   - State what changed
   - State what was verified (tests, queries, UI proof)
5) If ambiguity exists:
   - Re-scan the repo
   - Re-check this document
   - Do NOT invent new architecture without justification
6) No task is â€œdoneâ€ unless it is wired into:
   UI â†’ backend â†’ storage â†’ validation â†’ production (if applicable).

If you are unsure, STOP and re-read this document before continuing.

ğŸ”’ SYSTEM INSTRUCTION (READ FIRST)

You are building this completely and end-to-end.
No skeleton. No mock logic. No â€œfuture workâ€ placeholders.

If something is missing, design and implement it.
If something already exists, integrate with it.
If unsure, refer back to the Findings & Required Task Stubs document.

Semantic / NL / embeddings layer is explicitly deferred.
This is V1 = deterministic only.

ğŸ¯ OVERALL GOAL

Implement a deterministic What-If Analyzer that allows:

Testing conditional rules against historical data

Measuring impact on existing validated setups

Persisting reproducible snapshots

Promoting condition variants into the validation pipeline

Enforcing promoted conditions as live trading gates

Maintaining full lineage, auditability, and fail-closed behavior

This must integrate cleanly with:

Existing edge discovery

Validation (T6/T7)

Live scanning

Memory / monitoring systems (deterministic V1)

ğŸ§  REQUIRED SKILL USAGE (MANDATORY)

Invoke these explicitly and repeatedly during the work:

Design & Scope Control

brainstorming â€” before architecture or condition design (prevent bloat)

focus-mode â€” break work into small, finishable blocks

Navigation & Safety

quick-nav â€” to locate logic, flows, or data sources

code-guardian â€” auto-activate on any trading / pipeline / validation edits

Data & Integrity

database-design â€” before adding or changing any schema

strategy-validator â€” ensure all variants must pass full validation gates

Quality Control

code-review-pipeline â€” after each major task

project-organizer â€” if new components increase repo entropy

Runtime Intelligence (Deterministic V1)

trading-memory â€” persist outcomes + metadata (no LLM)

edge-evolution-tracker â€” register promoted variants for monitoring

market-anomaly-detection â€” enforce condition gates pre-trade

(UI aesthetics only where relevant)

frontend-design â€” What-If Analyzer panel only

mobile-android-design / mcp-builder â€” ignore for V1 unless explicitly needed

ğŸ“‹ WORK RULES (NON-NEGOTIABLE)

Break everything into numbered tasks

Each task must include:

Purpose

Inputs

Outputs

Definition of Done

Complete tasks in order

After each task:

Run checks/tests

Summarize what is now provably working

Refer back to the Findings document whenever unsure

Do not invent parallel architectures

ğŸ§© TASK LIST (AUTHORITATIVE)
âœ… Task 0 â€” Orientation & Constraints

Purpose

Establish boundaries and confirm V1 scope

Actions

Use quick-nav to locate:

Where setups are defined

Where validation is invoked

Where live scanning applies filters

Use brainstorming to select 2â€“4 deterministic V1 conditions
(e.g. ORB size thresholds, time-since-open, range compression)

DoD

Clear list of V1 conditions

Explicit confirmation of non-semantic V1

ğŸ§® Task 1 â€” What-If Analyzer Engine (Deterministic)

Purpose

Evaluate condition sets against historical data

Actions

Build a deterministic query engine that:

Accepts setup + condition rules

Computes:

baseline metrics

condition-matched metrics

non-matched metrics

deltas

Applies identical cost model + rules

Add caching keyed by:

setup

condition hash

data version

Skills

brainstorming

database-design

code-guardian

DoD

Same inputs always return same outputs

Cached results reused

No UI dependency

ğŸ“¸ Task 2 â€” Snapshot Persistence (Reproducibility)

Purpose

Persist exact What-If results as immutable artifacts

Actions

Design snapshot storage with:

Full condition definition

Query parameters

Metrics

Data/version metadata

Enable deterministic re-runs

Skills

database-design

trading-memory

DoD

Snapshots can be reloaded and re-evaluated

No hidden state or recomputation drift

ğŸ–¥ï¸ Task 3 â€” What-If Analyzer UI Panel

Purpose

Allow interactive exploration without logic leakage

Actions

Add a panel that:

Selects a base setup

Applies condition rules

Displays baseline vs conditional metrics

Saves snapshots explicitly

Skills

frontend-design

focus-mode

DoD

UI is read-only logic-wise

All actions call backend engine only

ğŸ” Task 4 â€” Validation Handoff (Variant Lineage)

Purpose

Turn snapshots into validate-able candidates

Actions

Enable â€œPromote Snapshot to Candidateâ€

Create variant lineage:

base setup â†’ condition variant

Force full validation pipeline (T6/T7)

Skills

strategy-validator

code-guardian

DoD

No bypass paths

Variants fail or pass like any other edge

ğŸš¦ Task 5 â€” Live Trading Condition Gates

Purpose

Enforce validated conditions in real time

Actions

Extend live scanning to:

Evaluate promoted condition rules

Block trades when conditions fail

Record block reasons

Skills

market-anomaly-detection

edge-evolution-tracker

DoD

Live decisions explain why a trade was blocked

No silent passes

ğŸ§ª Task 6 â€” End-to-End Tests

Purpose

Prove system integrity

Actions

Add tests covering:

Deterministic What-If evaluation

Snapshot round-trip

Validation promotion

Live gate enforcement

Skills

code-review-pipeline

strategy-validator

DoD

Full lifecycle tested

No manual steps required

ğŸ“˜ Task 7 â€” Documentation & Build Status

Purpose

Make the system operable without tribal knowledge

Actions

Document:

What-If workflow

Reproducibility guarantees

Operator expectations

Update build status

Skills

focus-mode

DoD

New capability clearly explained

No ambiguity

â–¶ï¸ START NOW

Invoke quick-nav to locate:

Setup definitions

Validation entry points

Live scan logic

Invoke brainstorming to lock V1 condition set

Begin Task 1

Do not skip steps.
Do not compress tasks.
Do not proceed without completing each DoD.
